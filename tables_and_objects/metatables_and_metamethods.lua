-- Метатаблицы позволяют изменить поведение значения при его
-- встрече с неожиданной операцией. Например, при помощи метатаблиц
-- мы можем определить то, как Lua вычисляет выражение а+b, где а и b —
-- это таблицы. Когда Lua пытается сложить две таблицы, он проверяет,
-- есть ли хотя бы в одной из них метатаблица и содержит ли эта
-- метатаблица поле __add. Если Lua находит это поле, он вызывает
-- соответствующее значение — так называемый метаметод, который
-- должен быть функцией, — для вычисления суммы.

-- Lua всегда создает новые таблицы без метатаблиц

local t = {}
print(getmetatable(t)) --> nil

-- Мы можем использовать функцию setmetatable, 
-- чтобы задать или изменить метатаблицу для любой таблицы

local t1 = {}
setmetatable(t, t1)
print(getmetatable(t) == t1) --> true

-- Строковая библиотека устанавливает
-- метатаблицу для строк. У всех прочих типов по умолчанию нет
-- метатаблиц

print(getmetatable("hi")) -- table: 0x01072ca177f8
print(getmetatable("xuxu")) -- table: 0x01072ca177f8
print(getmetatable(10)) -- nil
print(getmetatable(print)) -- nil
print(getmetatable(nil)) -- nil

-- Группа связанных между собой таблиц может совместно использовать
-- общую метатаблицу, которая описывает их общее поведение; таблица
-- может быть метатаблицей для самой себя, таким образом описывая свое
-- собственное индивидуальное поведение.

local function add_tables(a, b)
    local result = {}
    local max_len = math.max(#a, #b)

    for i = 1, max_len do
        local sum = (a[i] or 0) + (b[i] or 0)
        table.insert(result, sum)
    end

    return result
end

local mt = {
    __add = add_tables
}

-- достаточно чтобы у одной из двух была определена метатаблица с методом __add
-- для того чтобы всё корректно работало. Но так как то красивее

local t1 = {1,2,3}; setmetatable(t1, mt)
local t2 = {2,3,4}; setmetatable(t2, mt)
local t3 = t1 + t2

print(table.concat(t3, ", ")) -- 3, 5, 7

-- Математические метаметоды и сравнение (функции)
--     __add — (+) сложение;
--     __sub — (-) вычитание;
--     __mul — (*) умножение;
--     __div — (/) деление;
--     __pow — (^) возведение в степень;
--     __mod — (%) деление по модулю;
--     __idiv — (//) деление с изъятием целой части (5.3+);
--     __eq — (==) сравнение равенства;
--     __lt — (<) сравнение «меньше чем», в обратную сторону выполняется автоматически, реверсируя аргументы;
--     __le — (<=) сравнение «меньше или равно»;

-- Общие метаметоды

--     __index — функция или таблица, с помощью которых оригинальная таблица ищет ключи, если их не существует;
--     __newindex — функция, как добавлять в таблицу *новые* ключи, на уже существующие — не действует;
--     __call — фунция, которая вызовется когда таблицу попробуют вызвать как как функцию;
--     __tostring — функция, вызывающаяся при попытке преобразовать таблицу в строку, например, при print или tostring, сочетается с __concat;
--     __concat — функция, вызывающаяся при попытке конкатенации таблицы с чем либо, сочетается с __tostring;
--     __metatable — значение, которое возвращается попытке взять метатаблицу у данной таблицы, позволяет скрывать метатаблицы;
--     __mode — строка, управляющая «силой» связей в таблице при сборке мусора, с её помощью можно создавать таблицы слабых ссылок или эфемероны;
--     __gc — функция, которая будет вызвана при сборе userdata(5.1+) или таблицы(5.2+) мусорщиком, если очень хочется в 5.1 — есть способ применения;
--     __len — функция которая будет вызываться при попытке вычисления длины таблицы, с помощью оператора # (5.2+);
--     __pairs — функция, альтернатива итератора pairs для данной таблицы (5.2+);
--     __ipairs — функция, альтернатива ipairs (5.2+);

print()
local t = {1,2,3};
print(t) -- table: 0x02804c06bba8
mt = {
    __tostring = function (t) return table.concat(t, "") end
}
setmetatable(t, mt)
print(t) -- 123
print(getmetatable(t)) -- table: 0x023b8610a7a8
mt.__metatable = "0___0"
print(getmetatable(t)) -- 0___0
local _, msg = pcall(function ()
    setmetatable(t, mt)
end)
print(msg) -- ...: cannot change a protected metatable

--               _           _           
--              (_)         | |          
--               _ _ __   __| | _____  __
--              | | '_ \ / _` |/ _ \ \/ /
--              | | | | | (_| |  __/>  < 
--              |_|_| |_|\__,_|\___/_/\_\
--   ______ ______                       
--  |______|______|                      

-- Когда мы обращаемся к отсутствующему
-- полю в таблице, результатом является nil. Это так, но это не вся правда.
-- На самом деле при подобном обращении интерпретатор начинает искать
-- метаметод __index: если такого метода нет, что обычно и бывает, то
-- возвращается nil; иначе результат будет предоставлен этим
-- метаметодом.

-- Типичным примером является наследование

-- Пусть мы хотим
-- создать несколько таблиц, описывающих окна. Каждая таблица должна
-- описывать различные параметры окна, такие как положение, размер,
-- цветовая схема и т. п. Для всех этих параметров есть значения по
-- умолчанию и поэтому мы хотим строить объекты окон, задавая только
-- те значения, которые отличаются от значений по умолчанию. Первый
-- вариант — предоставить конструктор, заполняющий отсутствующие
-- поля. Второй вариант — сделать так, чтобы новые окна наследовали
-- любое отсутствующее поле от прототипа окон.

-- Как работает __index:
--     Метод __index получает 2 параметра:
--         Таблица, к которой обращаются
--         Ключ, по которому идёт обращение

print()

local prototype = {x = 0, y = 0, width = 100, height = 100}
mt = {
    __index = function (_, key)
        return prototype[key]
    end
}

local function new(o)
    setmetatable(o, mt)
    return o
end

local w = new({x=10, y=20})
print(w.x, w.y, w.width, w.height) -- 10      20      100     100

-- Использование метаметода __index для наследования в Lua настолько
-- распространено, что Lua предоставляет сокращенный вариант. Хотя его
-- и зовут методом, метаметод __index не обязан быть функцией: например,
-- он может быть таблицей. Когда он является функцией, Lua вызывает его,
-- передавая таблицу и отсутствующий ключ в качестве аргументов, как
-- мы только что видели. Когда он является таблицей, Lua перенаправляет
-- к ней обращение. Поэтому в нашем предыдущем примере мы могли
-- просто определить __index следующим образом:

local prototype = {x = 0, y = 0, width = 100, height = 100}
mt = {
    __index = prototype
}

local function new(o)
    setmetatable(o, mt)
    return o
end

local w = new({x=10, y=20})
print(w.x, w.y, w.width, w.height) -- 10      20      100     100

-- Использование таблицы в качестве метаметода __index дает простой
-- и быстрый способ реализации одиночного наследования. Функция, хотя
-- и более затратна, предоставляет больше гибкости: мы можем
-- реализовать множественное наследование, кэширование и ряд других
-- вариантов.

-- Когда мы хотим обратиться к таблице без вызова ее метаметода
-- __index, мы используем функцию rawget. Вызов rawget(t,i) осуществляет
-- непосредственный доступ к таблице t, то есть примитивное обращение
-- без использования метатаблиц. Применение непосредственного доступа
-- не ускорит ваш код (затраты на вызов функции уничтожат любую
-- прибавку).

print(
    rawget(w, "x"),
    rawget(w, "y"),
    rawget(w, "width"),
    rawget(w, "height")) -- 10      20      nil     nil

--                                   _           _           
--                                  (_)         | |          
--               _ __   _____      ___ _ __   __| | _____  __
--              | '_ \ / _ \ \ /\ / / | '_ \ / _` |/ _ \ \/ /
--              | | | |  __/\ V  V /| | | | | (_| |  __/>  < 
--              |_| |_|\___| \_/\_/ |_|_| |_|\__,_|\___/_/\_\
--   ______ ______                                           
--  |______|______|                                          

-- Метаметод __newindex делает то же, что и __index, но работает при
-- обновлениях таблиц, а не при доступе к ним. Когда вы присваиваете
-- значение отсутствующему индексу в таблице, интерпретатор ищет
-- метаметод __newindex: если он есть, то интерпретатор вызывает его
-- вместо выполнения присваивания

t = {1,2,3}
setmetatable(t, {
    __newindex = function (_, k, v)
        print("__newindex called with k = "..k..", value = "..v)
    end
})

t[1] = 2
t[2] = 3
t[3] = 4
t[4] = 5 -- __newindex called with k = 4, value = 4
print(table.concat(t, ", ")) -- 2, 3, 4

-- Подобно __index, если метаметод __newindex
-- является таблицей, то интерпретатор выполняет присваивание для этой
-- таблицы вместо исходной.

-- Совместное использование метаметодов __index и __newindex
-- позволяет реализовать в Lua ряд довольно мощных конструкций, таких
-- как таблицы, доступные только для чтения, таблицы со значениями по
-- умолчанию и наследование для объектно-ориентированного
-- программирования