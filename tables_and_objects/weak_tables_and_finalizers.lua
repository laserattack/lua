-- Lua осуществляет автоматическое управление памятью. Программы
-- создают объекты (таблицы, нити и т. п.), но функции уничтожения
-- объектов не существует. Lua автоматически уничтожает объекты,
-- которые становятся мусором, при помощи сборки мусора.

-- Слабые таблицы и финализаторы — это механизмы, которые вы
-- можете использовать в Lua, чтобы помочь сборщику мусора. Слабые
-- таблицы позволяют сбор объектов Lua, которые все еще доступны
-- программе, в то время как финализаторы позволяют сборку внешних
-- объектов, не находящихся под непосредственным контролем сборщика
-- мусора.

--                      _      _        _     _           
--                     | |    | |      | |   | |          
--  __      _____  __ _| | __ | |_ __ _| |__ | | ___  ___ 
--  \ \ /\ / / _ \/ _` | |/ / | __/ _` | '_ \| |/ _ \/ __|
--   \ V  V /  __/ (_| |   <  | || (_| | |_) | |  __/\__ \
--    \_/\_/ \___|\__,_|_|\_\  \__\__,_|_.__/|_|\___||___/

-- Сборщик мусора может собрать только то, что гарантированно
-- является мусором; он не может догадаться, что считаете мусором
-- именно вы. Типичным примером является стек, реализованный как
-- массив с индексом для вершины стека. Вы знаете, что допустима лишь
-- та часть массива, которая идет до вершины, но этого не знает Lua. 
-- Если вы выталкиваете элемент, просто уменьшая индекс вершины, то
-- оставшийся в массиве объект не является мусором для Lua.

-- Точно так же
-- любой объект, который хранится в глобальной переменной, не будет
-- мусором для Lua, даже если ваша программа никогда не воспользуется
-- им снова. В обоих случаях вам (т.е. вашей программе) придется
-- позаботиться о присваивании nil этим позициям, чтобы они в
-- дальнейшем не помешали уничтожению данного объекта.

-- Для некоторых конструкций нужно организовать дополнительное
-- взаимодействие между программой и сборщиком мусора. Типичным
-- примером является хранение в вашей программе коллекции всех живых
-- объектов определенного вида (например, файлов). Задача кажется
-- простой: вам лишь требуется вставлять каждый новый объект в
-- коллекцию. Однако, как только объект становится частью этой
-- коллекции, его уничтожение становится невозможным! Даже если на
-- него не ссылаются другие объекты, на него ссылается сама коллекция.

-- пример со стеком
local stack = {}
local top = 0
local function push(value)
    top = top + 1
    stack[top] = value
end
local function pop()
    local value = stack[top]
    stack[top] = nil  -- удаляем единственную ссылку на объект
    top = top - 1
    return value
end

-- пример с коллекцией 
local aliveObjects = {}
local function createObject()
    local obj = { name = "Object" }
    table.insert(aliveObjects, obj)
    return obj
end

local obj = createObject() -- obj просто содержит ссылку на объект
obj = nil -- ссылка удалилась
-- но это не единственная ссылка, на него еще есть ссылка в aliveObjects


-- Lua не может знать о том, что эта ссылка не должна препятствовать
-- утилизации данного объекта, если только вы не сообщили Lua этот факт

-- Слабые таблицы — это тот механизм, который вы используете,
-- чтобы указать Lua на то, что ссылка не должна препятствовать
-- уничтожению объекта. Слабая ссылка (weak reference) — это такая
-- ссылка на объект, которая не учитывается сборщиком мусора. Если все
-- ссылки, указывающие на объект, являются слабыми, то данный объект
-- утилизируется, а эти слабые ссылки каким-либо образом удаляются. Lua
-- реализует слабые ссылки как слабые таблицы: слабая таблица (weak
-- table) — это такая таблица, все ссылки которой являются слабыми. Это
-- значит, что если объект хранится только внутри слабых таблиц, то Lua
-- со временем его утилизирует.

-- Слабость таблицы задается полем __mode ее метатаблицы. Значение
-- этого поля, когда оно присутствует, должно быть строкой; если эта
-- строка равна "k", то ключи в этой таблице являются слабыми; если эта
-- строка равна "v", то слабыми являются значения в этой таблице; если эта
-- строка равна "kv", то и ключи, и значения в данной таблице являются
-- слабыми.

-- пример
local aliveObjects = {}
local function createObject()
    local obj = { name = "Object" }
    table.insert(aliveObjects, obj)
    return obj
end
local obj = createObject() -- obj просто содержит ссылку на объект
obj = nil -- ссылка удалилась, осталась только ссылка в aliveObjects
print(#aliveObjects) -- 1

local aliveObjects = {}
setmetatable(aliveObjects, { __mode="v" })
local function createObject()
    local obj = { name = "Object" }
    table.insert(aliveObjects, obj)
    return obj
end
local obj = createObject() -- obj просто содержит ссылку на объект
obj = nil -- ссылка удалилась, осталась только ссылка в aliveObjects
collectgarbage() -- приндительная очистка, вызовет удаление ссылки из aliveObjects
print(#aliveObjects) -- 0

-- Обратите внимание, что из слабой таблицы могут быть
-- утилизированы лишь объекты (ССЫЛКИ). Значения, например числа и логические
-- значения, сборщиком не собираются.

--    __ _             _ _                  
--   / _(_)           | (_)                 
--  | |_ _ _ __   __ _| |_ _______ _ __ ___ 
--  |  _| | '_ \ / _` | | |_  / _ \ '__/ __|
--  | | | | | | | (_| | | |/ /  __/ |  \__ \
--  |_| |_|_| |_|\__,_|_|_/___\___|_|  |___/


-- Метаметод __gc работает в 5.1 только по отношению к userdata-типам.

-- Создаем таблицу с финализатором
local function create_table_with_gc()
    local tbl = {value = "I'm a table"}

    -- newproxy возвращает userdata-указатель
    -- Это пустой userdata-объект, не содержащий никаких данных изначально
    -- аргумент true указывает, что объект должен иметь свою метатаблицу
    local proxy = newproxy(true)
    local proxy_mt = getmetatable(proxy)

    -- Настраиваем финализатор для proxy
    proxy_mt.__gc = function()
        print("Finalizing table with value: "..tostring(tbl.value))
    end

    -- Связываем proxy с нашей таблицей
    tbl._proxy = proxy
    return tbl
end

-- Тестируем
local my_table = create_table_with_gc()
my_table = nil
collectgarbage() -- Finalizing table with value: I'm a table
-- т.е. функция из __gc выполнилась перед очисткой мустора