---@diagnostic disable: assign-type-mismatch

--[[
В Lua существует восемь базовых типов: nil, boolean, number, string,
table, function, userdata и thread. Функция type возвращает имя типа
любого заданного значения
]]

print(type("hello, sailor")) -- string
print(type(10.4*3)) -- number
print(type(print)) -- function
print(type(type)) -- function
print(type(true)) -- boolean
print(type(nil)) -- nil
-- Результат type всегдя является строкой
print(type(type('x'))) -- string
print(type(type(123))) -- string


-- Любая переменная может соержать значение любого типа
--[[
Тип nil — это тип с единственным значением, nil, основная задача
которого состоит в том, чтобы отличаться от всех остальных значений.
Lua использует nil как нечто, не являющееся значением.
]]
---@diagnostic disable: undefined-global, lowercase-global
print(type(a)) -- nil ('a' не инициализирована, глобальные переменные по умолчанию nil)
a = 10
print(type(a)) -- number
a = "a string!!"
print(type(a)) -- string
a = print
a(type(a)) -- function

-- ░▒▓███████▓▒░ ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░      ░▒▓████████▓▒░░▒▓██████▓▒░░▒▓███████▓▒░  
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
-- ░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓██████▓▒░ ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 
-- ░▒▓███████▓▒░ ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓████████▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ 

--[[
Тип boolean обладает двумя значениями — true и false, которые
представляют традиционные логические (или булевы) значения. Однако,
не только булевы значения могут выражать условие: в Lua условие
может быть представлено любым значением. Проверки условий
(например, условий в управляющих структурах) считают nil и булево
false ложными, а все прочие значения истинными. В частности, при
проверках условий Lua считает ноль и пустую строку истинными
значениями.
]]

a = nil
if a then
    print("true")
else
    print("false") -- 
end

a = false
if a then
    print("true")
else
    print("false") -- 
end

a = true
if a then
    print("true") -- 
else
    print("false")
end

a = "hello, sailor!"
if a then
    print("true") -- 
else
    print("false")
end

a = ""
if a then
    print("true") -- 
else
    print("false")
end

a = 0
if a then
    print("true") -- 
else
    print("false")
end

-- ░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓██████████████▓▒░░▒▓███████▓▒░░▒▓████████▓▒░▒▓███████▓▒░ ░▒▓███████▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░░▒▓██████▓▒░ ░▒▓███████▓▒░ ░▒▓██████▓▒░  
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░ 
-- ░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░                                                                                    

-- Тип number представляет вещественные числа, т.е. числа двойной
-- точности с плавающей точкой (тип double в C). В Lua нет
-- целочисленного типа (тип integer в C).

-- Мы можем записывать числовые константы вместе с необязательной
-- десятичной дробной частью и необязательным десятичным порядком.
-- Примеры допустимых числовых констант:
a = 4
a = 0.4
a = 4.57e-3
a = 5E+20
-- Более того, мы также можем использовать шестнадцатеричные
-- константы, применив префикс 0x. Начиная с Lua 5.2, шестнадцатеричные
-- константы также могут иметь дробную часть и двоичный порядок (с
-- префиксом 'р' или 'Р'), как в следующих примерах:
a = 0xdeadbeef
a = 0x0.2 -- 0.125
a = 0x1p-1 -- 0.5
print(a)

--  ░▒▓███████▓▒░▒▓████████▓▒░▒▓███████▓▒░░▒▓█▓▒░▒▓███████▓▒░ ░▒▓██████▓▒░ ░▒▓███████▓▒░ 
-- ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
-- ░▒▓█▓▒░         ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░        
--  ░▒▓██████▓▒░   ░▒▓█▓▒░   ░▒▓███████▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒▒▓███▓▒░░▒▓██████▓▒░  
--        ░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░ 
--        ░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░ 
-- ░▒▓███████▓▒░   ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░░▒▓███████▓▒░                                                                                     

-- Строки в lua - последовательности 8-битовых символов
a = "jopa"

print(a[2]) -- nil, т.к. строка - не таблица, а фундаментальный тип
print(string.sub(a, 2, 2)) -- o (подстрока от 2 до 2 символа)

print("str len =", #a) -- 4 (# - префиксная операция, называемая операцией длины)

for i = 1, #a do
    local byte = string.byte(a, i)
    print(i, byte, string.char(byte))
end

-- Символ строки также можно задать с помощью 
-- его числового значения, используя экранирование

a = "jopa"
b = "\106\111\112\97"
print(a, b) -- jopa    jopa

-- Сырые строки (в них нет экранирования)

raw = [[\106\111\112\97]]
print(raw) -- \106\111\112\97

-- Lua обеспечивает автоматическое преобразование между числами и
-- строками во время выполнения программ. Любая числовая операция,
-- примененная к строке, пытается преобразовать эту строку в число

print("10" + 1) -- 11
print("10 + 1") -- 10 + 1
print("-5.3e-10"*"2") -- -1.06e-09
-- print("hello" + 1) -- error

-- Верно и обратное — каждый раз, когда Lua находит число там, где
-- ожидает строку, он преобразует это число в строку

print(10 .. 20) -- 1020 (.. - конкатенация строк)

-- ░▒▓████████▓▒░▒▓██████▓▒░░▒▓███████▓▒░░▒▓█▓▒░      ░▒▓████████▓▒░░▒▓███████▓▒░ 
--    ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░        
--    ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░        
--    ░▒▓█▓▒░  ░▒▓████████▓▒░▒▓███████▓▒░░▒▓█▓▒░      ░▒▓██████▓▒░  ░▒▓██████▓▒░  
--    ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░ 
--    ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░ 
--    ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░░▒▓████████▓▒░▒▓████████▓▒░▒▓███████▓▒░  

-- Тип table представляет ассоциативные массивы. Ассоциативный
-- массив — это массив, который может быть индексирован не только
-- числами, но и строками или любым другим значением языка, КРОМЕ nil.

-- Таблицы являются ЕДИНСТВЕННЫМ механизмом структурирования данных в Lua

-- Мы используем таблицы для представления обычных
-- массивов, множеств, записей и других структур данных простым,
-- однородным и эффективным способом. Также Lua использует таблицы
-- для представления ПАКЕТОВ и ОБЪЕКТОВ. Когда мы пишем io.read, мы
-- думаем о «функции read из модуля io». Для Lua это выражение означает
-- «индексировать таблицу io, используя строку read в качестве ключа».

-- Таблица - динамически выделяемый объект
-- Программа работает только с ссылками на таблицы
-- Никогда в Lua нет скрытого копирования или создания новой таблицы

a = {} -- создает таблицу и сохраняет ссылку на нее в 'a'

k = "x"
a[k] = 10 -- новая запись с ключом "x" и значением 10
print(a["x"]) -- 10
a["x"] = a["x"] + 1 -- инкрементирует запись "x"
print(a["x"]) -- 11

a[20] = "great" -- новая запись с ключом 20 и значением "great"
k = 20
print(a[k]) -- great

-- Не существует постоянной связи между
-- переменной, которая хранит таблицу, и самой таблицей

a = {}
a["x"] = 10
b = a
print(a["x"]) --> 10
print(b["x"]) --> 10
b["x"] = 20
print(a["x"]) --> 20

a = nil -- лишь 'b' по-прежнему ссылается на ту таблицу
b = nil -- ссылок на таблицу не осталось

-- Когда в программе больше не остается ссылок на таблицу, сборщик
-- мусора Lua со временем удалит эту таблицу, чтобы повторно
-- использовать ее память.

-- Каждая таблица может хранить значения с разными типами индексов и значений
-- и растет по мере добавления новых записей

a = {}
for i = 1, 1000 do a[i] = i end
print(a[555]) --> 555

a['x'] = 10
print(a['x']) --> 10
a['y'] = 'string'
print(a['y']) --> string

b = {}
b[1] = 'table'
a[b] = b -- таблица в качестве ключа и значения по этому ключу
print(a[b][1]) -- table

-- table.text (точечная нотация) - 
-- синтаксический сахар для table['text'] (строковая нотация)

a = {}
a['name'] = 'serr'
print(a['name'], a.name) -- serr    serr

-- Для Lua эти две формы эквивалентны и могут свободно использоваться
-- вместе. Для читателя, однако, каждая форма может сообщать о разном
-- намерении. Точечная нотация ясно показывает, что мы используем
-- таблицу как запись, где у нас есть некоторый набор постоянных,
-- предопределенных ключей. Строковая нотация дает представление о
-- том, что у таблицы в качестве ключа может быть любая строка, и что по
-- некоторой причине мы работаем с этим конкретным ключом.

-- Чтобы представить традиционный массив или список, просто
-- используйте таблицу с целочисленными ключами. Нет ни способа, ни
-- необходимости объявлять размер; вы всего лишь инициализируете те
-- элементы, которые вам нужны

a = {}
for i = 1, 1000 do a[i] = i end
print(a[1]) -- 1

local ffi = require("ffi")

-- Интересная особенность с null и nil в LuaJIT

null = ffi.new("void*")
print(null == nil) -- true

if null then
    print(123) -- печатается
end

if nil then
    print(124) -- не печатается
end