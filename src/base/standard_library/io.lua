-- Чтобы открыть файл, вы используете функцию io.open, которая
-- подобна функции fopen в С. В качестве аргументов она принимает имя
-- файла, который нужно открыть, и строку режима (mode string). Эта
-- строка может содержать 'r' для чтения, 'w' для записи (которая при этом
-- стирает любое предыдущее содержимое файла) или 'a' для добавления к
-- файлу; еще она может содержать необязательный 'b' для открытия
-- двоичных файлов. Функция open возвращает новый дескриптор файла. В
-- случае ошибки open возвращает nil, а также сообщение об ошибке и ее
-- код

local filename = "text"

local f = assert(io.open(filename, "w"))
print(f) -- file (0x5940802802a0)
f:write[[
hello, sailor! 1
hello, sailor! 2
hello, sailor! 3
hello, sailor! 4
hello, sailor! 5
hello, sailor! 6
]]
f:close()
print(f) -- file (closed)

-- *а читает весь файл
-- *l читает следующую строку (без символа перевода строки)
-- *L читает следующую строку (с символом перевода строки)
-- *n читает число (число ограничивает количество читаемых символов)

local f = assert(io.open(filename, "r"))
local all_text = f:read("*a")
print(all_text)

f:seek("set") -- каретку в начало файла

repeat
    local line = f:read("*l") -- читает по одной линии
    if line then
        io.write(line, "\n") -- как print только просто пишет в stdout без разделителей, без преобразований автоматических
    else
        print("end of file")
    end
until not line

f:seek("set") -- каретку в начало файла
print()

-- Аналогичное можно записать короче:

-- f:lines() returns an iterator function that, each time it is called, returns a new line from the file.

local iter = f:lines()
for l in iter do
    print(l)
end

f:close()
os.remove(filename)

print()

-- Небольшой прием для увеличения быстродействия

-- Обычно в Lua быстрее прочесть файл целиком, чем читать его строка
-- за строкой. Однако, иногда мы сталкиваемся с большим файлом
-- (например, десятки или даже сотни мегабайт), читать который целикомбыло бы нецелесообразно. Если вы хотите получить максимальное
-- быстродействие при работе с такими большими файлами, то быстрее
-- всего будет читать его достаточно большими кусками (например, по
-- 8К). Во избежание возможного разрыва строки, можно про сто
-- попросить прочесть еще одну строку:
-- local lines, rest = f:read(BUFSIZE, "*l")
-- Переменная rest получит остаток любой строки, разбитой при чтении
-- куска. Затем мы объединяем кусок и полученный остаток. Таким
-- образом кусок всегда будет завершаться на границе строк.

-- Библиотека ввода-вывода предлагает дескрипторы для трех
-- предопределенных потоков С: io.stdin, io.stdout и io.stderr. Поэтомувы можете послать сообщение прямо в поток вывода при помощи
-- примерно такого кода:

io.stdout:write("hello, standard output!\n")

-- Функция flush применяет к файлу все отложенные операции записи.
-- local file = io.open("test.txt", "w")
-- file:write("какой то текст!")
-- file:flush()  -- Принудительная запись на диск
-- -- Теперь файл точно содержит данные, даже если программа аварийно завершится
-- file:close()


-- Метод seek может как возвращать, так и устанавливать текущую
-- позицию
-- внутри
-- файла.
-- Его
-- общей
-- формой
-- является
-- f:seek(место,смещение), где место — это строка, задающая, как надо
-- интерпретировать смещение. Ее допустимыми значениями являются
-- "set", когда смещение трактуется от начала файла, "cur", когда смещение
-- трактуется от текущей позиции внутри файла, и "end", когда смещение
-- трактуется с конца файла. Независимо от значения места вызов
-- возвращает новую текущую позицию, измеренную в байтах от начала
-- этого файла.
-- Значениями по умолчанию являются "cur" для места и 0 для
-- смещения. Поэтому вызов file:seek() возвращает текущее положение
-- внутри файла, не меняя его; вызов file:seek("set") возвращает позицию
-- в начало файла (и возвращает ноль); а вызов file:seek("end")
-- устанавливает позицию на конец файла и возвращает его размер.
-- Следующая функция получает размер файла, не меняя текущую позицию
-- внутри него:

-- local function fsize (file)
--     local current = file:seek()
--     local size = file:seek("end")
--     file:seek("set", current)
--     return size
-- end