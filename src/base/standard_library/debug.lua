-- Отладочная библиотека не является отладчиком, но она предложит
-- все необходимые примитивы для написания вашего собственного
-- отладчика для Lua. Из соображения быстродействия официальным
-- интерфейсом к этим примитивам является C API. Отладочная
-- библиотека в Lua — это способ получить к ним доступ напрямую из
-- кода Lua.
-- В отличие от других библиотек, вы не должны использовать
-- отладочную библиотеку слишком часто. Во-первых, часть ее
-- функциональности не отличается быстродействием. Во-вторых, она
-- нарушает некоторые непреложные истины языка, например то, что вы не
-- можете обратиться к локальной переменной вне ее лексической области
-- видимости. Скорее всего вы решите отказаться от использования этой
-- библиотеки в финальной версии продукта, а то и вовсе захотите ее
-- стереть.

-- Отладочная библиотека состоит из двух видов функций:
-- интроспективные функции и ловушки. Интроспективные функции
-- (introspective function) позволяют изучать различные стороны
-- выполняемой программы, такие как стек ее активных функций, текущая
-- выполняемая строка, значения и имена локальных переменных. Ловушки
-- (hook) позволяют нам отслеживать выполнение программы.

--              _   _        __      
--             | | (_)      / _|     
--    __ _  ___| |_ _ _ __ | |_ ___  
--   / _` |/ _ \ __| | '_ \|  _/ _ \ 
--  | (_| |  __/ |_| | | | | || (_) |
--   \__, |\___|\__|_|_| |_|_| \___/ 
--    __/ |                          
--   |___/                           

local function foo(a,b,c)
    local var = 123
    print("var = ", var)
end

local foo_info = debug.getinfo(foo)

for k, v in pairs(foo_info) do
    print(k,v)
end

-- what    Lua                                              --> что за ф-я (Си или Луа)
-- nups    0                                                --> количество верхних значений для этой функции (0 - значит не использует переменные из внешних областей видимости)
-- nparams 3                                                --> количество аргументов
-- isvararg        false                                    --> вариадическая? (есть ли ...)
-- func    function: 0x7e3cb0da95f0                         --> сама функция
-- currentline     -1                                       --> текущая строка выполнения
-- namewhat                                                 --> global/local/field или пустая строка если не нашлось имя функции
-- source  @src/base/standard_library/debug.lua             --> где была определена
-- short_src       src/base/standard_library/debug.lua      --> короткая версия source (до 60 символов)
-- linedefined     23                                       --> номер первой строки в source где ф-я была определена
-- lastlinedefined 25                                       --> номер последней строки

-- Первый параметр getinfo также может быть стековым уровнем

print()

print(debug.getinfo(1).currentline) -- номер строки с этим вызовом

-- getinfo - очень тяжелая функция, можно указывать конкретно что искать, 
-- чтобы она не искала всё (была менее тяжелая)

-- 'n' name, namewhat
-- 'f' func
-- 'S' source, short_src, what, linedefined, lastlinedefined
-- 'l' currentline
-- 'L' activelines
-- 'u' nup

print(debug.getinfo(1, "l").currentline) -- номер строки с этим вызовом
print(debug.getinfo(1, "l").isvararg) -- nil (так как указано "l" вторым параметром)

--              _   _                 _ 
--             | | | |               | |
--    __ _  ___| |_| | ___   ___ __ _| |
--   / _` |/ _ \ __| |/ _ \ / __/ _` | |
--  | (_| |  __/ |_| | (_) | (_| (_| | |
--   \__, |\___|\__|_|\___/ \___\__,_|_|
--    __/ |                             
--   |___/                              

print()

local function foo(a,b,c)
    local var = 123
    print(debug.getlocal(1, 1)) -- a       1
    print(debug.getlocal(1, 2)) -- b       2
    print(debug.getlocal(1, 3)) -- c       3
    print(debug.getlocal(1, 4)) -- var     123
end

foo(1,2,3)

--   _                 _        
--  | |               | |       
--  | |__   ___   ___ | | _____ 
--  | '_ \ / _ \ / _ \| |/ / __|
--  | | | | (_) | (_) |   <\__ \
--  |_| |_|\___/ \___/|_|\_\___/

-- Lua вызывает ловушки с единственным аргументом — строкой,
-- описывающей событие, которое привело в вызову: "call" (или "tail
-- call"), "return", "line" или "count". Для события строки также передается
-- второй аргумент — новый номер строки. Для получения
-- дополнительной информации внутри ловушки следует использовать
-- debug.getinfо.
-- Чтобы зарегистрировать ловушку, мы вызываем функцию
-- debug.sethook с двумя или тремя аргументами: первый аргумент — это
-- функция ловушки; второй аргумент — это фильтрующая строка, которая
-- описывает, какие именно события мы хотим отслеживать; и
-- необязательный третий аргумент — это число, задающее с какой
-- частотой мы хотим получать события счетчика.

print()

local function trace_hook(event)
    local info = debug.getinfo(2)
    if event == "call" then
        print("→ CALL:", info.name or "?", info.short_src, info.linedefined)
    elseif event == "return" then
        print("← RETURN:", info.name or "?")
    end
end

debug.sethook(trace_hook, "cr")

local function foo()
    print("Inside foo")
end

foo()

-- → CALL: foo     src/base/standard_library/debug.lua     128
-- → CALL: print   [C]     -1
-- Inside foo
-- ← RETURN:       foo
-- ← RETURN:       ?