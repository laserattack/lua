
-- Любой итератор должен где-то хранить свое состояние между
-- последовательными вызовами, чтобы знать, где он находится и как себя
-- вести с этого места. Замыкания предоставляют великолепный механизм
-- для этой задачи. Вспомним, что замыкание — это функция, которая
-- обращается к одной или нескольким локальным переменным из
-- охватывающего ее окружения. Эти переменные хранят свои значения
-- между последовательными вызовами замыкания, позволяя тем самым
-- замыканию помнить, где оно находится при переборе элементов.
-- Разумеется, для создания нового замыкания мы также должны создать
-- его нелокальные переменные. Поэтому конструкция замыкания обычно
-- включает в себя две функции: само замыкание и фабрику — функцию,
-- которая создает замыкание вместе с окружающими ее переменными.

local function values(t) -- фабрика замыканий (итераторов в данном случае)
    local i = 0
    return function() -- замыкание (итерирующая функция aka итератор)
        i = i + 1
        return t[i]
    end
end

local list = {1,2,3,4}

-- вариант с обычным циклом
local iter = values(list)
while true do
    local element = iter()
    if element == nil then break end
    print(element)
end

-- вариант с общим for
-- Общий for ведет для итерирующего цикла всю бухгалтерию: он хранит
-- внутри итерирующую функцию, поэтому нам не нужна переменная iter;
-- он вызывает итератор для каждой новой итерации; и он останавливает
-- цикл, когда итератор возвращает nil.
for element in values(list) do
    print(element)
end


-- Рассмотрим итератор pairs
local t = {"one","two","tree"}
for k, v in pairs(t) do
    print(k, v)
end

-- for <список_переменных> in <список_выражений> do
--     <тело>
-- end

--[[
Первая переменная в списке переменных (в данном случае - k) называется
управляющей переменной. 
В течение всего цикла ее значение никогда не равно nil, поскольку когда
она становится равной nil, цикл завершается.
]]

-- Первое, что делает цикл for, — вычисляет выражения после in. Эти
-- выражения должны дать три значения, которые хранит for: итерирующая
-- функция, инвариантное состояние и начальное значение управляющей
-- переменной

-- тут получаем function, list, 0

-- Затем for присваивает значения, возвращенные
-- итерирующей функцией, переменным, объявленным в его списке
-- переменных. 

-- т.е. то что вернула function (в данном случае 1 и "a") присваивается в index и value соответственно

-- Оператор for вызывает свою
-- итерирующую функцию с двумя аргументами: инвариантное остояние и
-- управляющая переменная.

-- Перепишу values в этом стиле
-- т.е. в данном случае invariant_state и control_variable не используются
-- это итератор, хранящий свое состояние. т.е. занчение переменной i хранится между вызовами

local function values(t)
    local i = 0
    local invariant_state = nil
    local control_variable = nil
    return function(invariant_state, control_variable)
        i = i + 1
        return t[i]
    end, invariant_state, control_variable
end

list = {"a", "b", "c", "d"}

for element in values(list) do
    print(element)
end

-- Но данный итератор может быть усовершенствован в stateless iterator, 
-- т.е. итератор, не хранящий свое состояние, с использованием незадействованных переменных

list = {"a", "b", "c", "d"}

local iter = function(invariant_state, control_variable)
        control_variable = control_variable + 1
        local value = invariant_state[control_variable]
        if value then
            return control_variable, value
        end
    end

local function values(invariant_state)
    return iter, invariant_state, 0  -- начальное состояние control_variable - 0
end

-- сначала вызовется iter(invariant_state, 0)
-- потом iter(invariant_state, 1)
-- потом iter(invariant_state, 2)
-- ...

for k, v in values(list) do
    print(k, v)
end

-- В lua есть стандартная функция next, Вызов next(t,k), где k это ключ таблицы t, 
-- возвращает следующий
-- ключ в таблице в произвольном порядке, а также связанное с этим
-- ключом значение как второе возвращаемое значение.

-- т.е. values можно переписать так

local function values(invariant_state)
    return next, invariant_state, 0  -- начальное состояние control_variable - 0
end

for k, v in values(list) do
    print(k, v)
end