-- строки в Lua immutable

-- Строковая библиотека экспортирует свои функции в виде модуля с
-- именем string. Начиная с Lua 5.1, она также экспортирует свои функции
-- как методы, принадлежащие типу string (при помощи метатаблицы
-- данного типа). Поэтому, например, перевод строки в заглавные буквы
-- можно записать либо как string.upper(s), либо как s:upper(). Выбирайте
-- сами.

-- for k in pairs(string) do print(k) end
-- Все что есть в string:

-- find --> ищет образец внутри заданной строки, возвращает пару индексов - начало и конец совпадения. или nil если совпадение не найдено
-- match --> она возвращает часть обрабатываемой строки, удовлетворяющую образцу
-- gmatch --> возвращает функцию, которая перебирает все вхождения образца в строку (итератор)
-- gsub --> замена всех вхождений образца на замещающую строку внутри обрабатываемой
-- format --> использует форматирующую строку и след. аргументы для создания результирующей строки (типо аналог printf из Си)
-- len --> возвращаетдлину строки. Экивалентно оператору длины #
-- byte --> возвращает внутреннее числовое представление символа/символов строки (см ниже)
-- char --> принимает целые числа, преобразует каждое из них в символ и возвращает строку, в которой все эти символы соединены
-- sub --> извлекает часть строки, ограниченную индексами (есть нюансы, см ниже)
-- rep --> возвращает строку, повторенную n раз
-- reverse --> реверсит строку (hello <-> olleh)
-- lower --> возвращает копию строки, у которой заглавные буквы преобразованы в строчные
-- upper --> возвращает копию строки, у которой строчные буквы преобразованы в заглавные
-- dump --> преобразует загруженную функцию (Lua-функцию, но не C-функцию) в бинарную строку (байткод), которую можно сохранить или передать


-- string.rep
-- возвращает строку, повторенную n раз, можно также указать опциональный разделитель
local s = "123"
print(s:rep(10, ", ")) -- 123, 123, 123, 123, 123, 123, 123, 123, 123, 123
-- local big_string = string.rep("a", 2^20) -- строка весом 1мб


-- string.sub
-- можно применять отрицательные индексы
-- отрицательные индексы отсчитываются от конца строки
local s = "hello, sailor!"
print(s:sub(8)) --> sailor!
print(s:sub(8, 13)) --> sailor
print(s:sub(8, 7)) --> ""
print(s:sub(8, -2)) --> sailor


-- string.byte
local s = "hello, sailor!"
print(s:byte()) -- 104 (первый символ)
print(s:byte(1)) -- 104 (первый символ)
print(s:byte(2)) -- 101 (второй символ)
print(s:byte(-1)) -- 33 (последний символ)
print(
    table.concat(
        {s:byte(1, 5)},
        ", "
    )
) -- 104, 101, 108, 108, 111 (первые 5 символов)
print(
    table.concat(
        {s:byte(1, -1)},
        ", "
    )
) -- 104, 101, 108, 108, 111, 44, 32, 115, 97, 105, 108, 111, 114, 33 (вся строка)

-- в Lua есть ограничение на кол-во возвращаемых функцией значений
-- так что тут функция byte вызовет исключение
print(
    select(2, pcall(function ()
        local big_string = string.rep("1", 2^20) -- строка весом 1мб
        local _ = {big_string:byte(1, -1)} -- пытаюсь получить таблицу байт строки
    end))
) -- string slice too long


-- string.char
local s = "hello, sailor!"
---@diagnostic disable-next-line: missing-parameter
print(string.char()) -- ""
print(string.char(97)) -- a
print(string.char(97, 98, 99)) -- abc
print(string.char(s:byte(), s:byte(2))) -- he
print(string.char(s:byte(1, 4))) -- hell

-- Функция string.format — это мощный инструмент для
-- форматирования строк, обычно для вывода. Она возвращает
-- отформатированную версию всех своих аргументов (так как является
-- варидической), следуя описанию, заданному своим первым аргументом,
-- так называемой форматирующей строкой (format string).
-- Форматирующая строка следует правилам, похожим на те, что
-- используются в функции printf стандартного С
print()
print(
    string.format("pi = %.4f", math.pi)
) -- pi = 3.1416
print(
    string.format("%s: %d", "unix timestamp", os.time())
) -- unix timestamp: 1753522683

local d, m, y = 5, 11, 1990
print(
    -- типо если меньше 2/4 символов то нули допишет слева
    string.format("%02d/%02d/%04d", d, m, y) -- 05/11/1990
)


-- string.reverse
s = "hello, sailor!"
print(
    s:reverse() -- !rolias ,olleh
)


-- string.dump 
print()

-- Вариант 1
-- Дамп с отладочной информацией (по умолчанию)
local func = function(a, b) return a + b end
local dump = string.dump(func)
print(
    string.format("dump size = %d", #dump)
) -- dump size = 67

-- сохранение дампа в файл
local tmp = os.tmpname()
local f = io.open(tmp, "wb"); assert(f)
f:write(dump)
f:close()

-- загрузка функции из файла
local f = io.open(tmp, "rb"); assert(f)
local dump = f:read("*a"); f:close()
local func = loadstring(dump); assert(func)
print(func(2003, 22)) -- 2025

-- Вариант 2
-- Дамп без отладочной информации (меньший размер файла)
local func = function(a, b) return a + b end
local dump = string.dump(func, true)
print(
    string.format("dump size = %d", #dump)
) -- dump size = 22

-- сохранение дампа в файл
local tmp = os.tmpname()
local f = io.open(tmp, "wb"); assert(f)
f:write(dump)
f:close()

-- загрузка функции из файла
local f = io.open(tmp, "rb"); assert(f)
local dump = f:read("*a"); f:close()
local func = loadstring(dump); assert(func)
print(func(2003, 22)) -- 2025

--               _   _                                        _       _     _             
--              | | | |                                      | |     | |   (_)            
--   _ __   __ _| |_| |_ ___ _ __ _ __ ______ _ __ ___   __ _| |_ ___| |__  _ _ __   __ _ 
--  | '_ \ / _` | __| __/ _ \ '__| '_ \______| '_ ` _ \ / _` | __/ __| '_ \| | '_ \ / _` |
--  | |_) | (_| | |_| ||  __/ |  | | | |     | | | | | | (_| | || (__| | | | | | | | (_| |
--  | .__/ \__,_|\__|\__\___|_|  |_| |_|     |_| |_| |_|\__,_|\__\___|_| |_|_|_| |_|\__, |
--  | |                                                                              __/ |
--  |_|                                                                             |___/ 

-- Наиболее эффективными функциями в строковой библиотеке
-- являются функци find (поиск), match (сопоставление), gsub (глобальная
-- замена) и gmatch (глобальное сопоставление). Все они основаны на
-- образцах (pattern).

--    __ _           _ 
--   / _(_)         | |
--  | |_ _ _ __   __| |
--  |  _| | '_ \ / _` |
--  | | | | | | | (_| |
--  |_| |_|_| |_|\__,_|

-- Функция string.find ищет образец внутри заданной обрабатываемой
-- строки. Простейшей формой образца является слово, которое
-- соответствует лишь копии самого себя. Например, образец 'hello' задаст
-- поиск подстроки "hello" внутри обрабатываемой строки. При
-- нахождении образца find возвращает два значения: индекс, с которого
-- начинается совпадение, и индекс, на котором совпадение заканчивается.
-- Если совпадение не найдено, возвращается nil

print()

s = "hello, sailor!"
print(s:find("hello")) -- 1, 5
---@diagnostic disable-next-line: param-type-mismatch
print(s:sub(s:find("hello"))) -- hello

-- У функции string.find есть необязательный третий параметр: индекс,
-- указывающий, с какого места обрабатываемой строки следует начать
-- поиск.
print(s:find("hello", 1)) -- 1, 5
print(s:find("hello", 2)) -- nil

-- есть также необязательный 4-й параметр 
-- Что делает параметр plain?
--     Если plain = true:
--     Отключает интерпретацию pattern как регулярного выражения (шаблона) и ищет точное совпадение с подстрокой.
--     Если plain = false (или опущен):
--     pattern обрабатывается как регулярное выражение (Lua-паттерн).

--                   _       _     
--                  | |     | |    
--   _ __ ___   __ _| |_ ___| |__  
--  | '_ ` _ \ / _` | __/ __| '_ \ 
--  | | | | | | (_| | || (__| | | |
--  |_| |_| |_|\__,_|\__\___|_| |_|

print()

-- Функция string.match похожа на string.find в том смысле, что она
-- тоже ищет образец в строке. Однако, вместо возвращения тех позиций,
-- где был найден образец, она возвращает часть обрабатываемой строки,
-- удовлетворяющую образцу

s = "hello, sailor!"
print(s:match("hello")) -- hello

-- принимает также необязательный параметр init (3й параметр),
-- указывающий, с какого места обрабатываемой строки следует начать поиск

print(s:match("hello", 1)) -- hello
print(s:match("hello", 2)) -- nil

--                   _     
--                  | |    
--    __ _ ___ _   _| |__  
--   / _` / __| | | | '_ \ 
--  | (_| \__ \ |_| | |_) |
--   \__, |___/\__,_|_.__/ 
--    __/ |                
--   |___/                 

print()

-- У функции string.gsub три обязательных параметра: обрабатываемая
-- строка, образец и замещающая строка. Ее основное применение состоит
-- в замене всех вхождений образца на замещающую строку внутри
-- обрабатываемой

-- возвращает новую строку и количество произведенных замен

s = "Lua is cute"
print(s:gsub("cute", "great")) -- Lua is great    1

s = "Lua is cute cute cute cute cute cute"
print(s:gsub("cute", "great")) -- Lua is great great great great great great      6

-- необязательный 4-й параметр ограничивает количество замен

s = "Lua is cute cute cute cute cute cute"
print(s:gsub("cute", "great", 4)) -- Lua is great great great great cute cute        4

--                         _       _     
--                        | |     | |    
--    __ _ _ __ ___   __ _| |_ ___| |__  
--   / _` | '_ ` _ \ / _` | __/ __| '_ \ 
--  | (_| | | | | | | (_| | || (__| | | |
--   \__, |_| |_| |_|\__,_|\__\___|_| |_|
--    __/ |                              
--   |___/                               

-- Функция string.gmatch возвращает функцию, которая перебирает все
-- вхождения образца в строку. Например, следующий пример собирает все
-- слова в заданной строке
-- (Как мы вскоре обсудим, образец '%а+' соответствует
-- последовательностям из одной или более букв)

s = "hello, sailor!"
for w in s:gmatch("%a+") do
    print(
        string.format("word: %s", w)
    )
end
-- word: hello
-- word: sailor


--               _   _                      
--              | | | |                     
--   _ __   __ _| |_| |_ ___ _ __ _ __  ___ 
--  | '_ \ / _` | __| __/ _ \ '__| '_ \/ __|
--  | |_) | (_| | |_| ||  __/ |  | | | \__ \
--  | .__/ \__,_|\__|\__\___|_|  |_| |_|___/
--  | |                                     
--  |_|                                     

--                       _           _        _                         
--                      | |         | |      | |                        
--   ___ _   _ _ __ ___ | |__   ___ | |   ___| | __ _ ___ ___  ___  ___ 
--  / __| | | | '_ ` _ \| '_ \ / _ \| |  / __| |/ _` / __/ __|/ _ \/ __|
--  \__ \ |_| | | | | | | |_) | (_) | | | (__| | (_| \__ \__ \  __/\__ \
--  |___/\__, |_| |_| |_|_.__/ \___/|_|  \___|_|\__,_|___/___/\___||___/
--        __/ |                                                         
--       |___/                                                          

-- Класс символов (character class) — это элемент в образце,
-- который может соответствовать любому символу из заданного
-- множества.

-- Например, класс %d соответствует любой цифре. Таким
-- образом, вы можете искать дату в формате dd/mm/yyyy при помощи
-- образца '%d%d/%d%d/%d%d%d%d'

local s = "Deadline is 30/05/1999, firm"
local re = "%d%d/%d%d/%d%d%d%d"
print(s:match(re)) -- 30/05/1999

-- Все классы символов
-- . все символы
-- %a буквы
-- %c управляющие символы
-- %d цифры
-- %g печатные символы кроме пробельных
-- %l строчные буквы
-- %p символы пунктуации
-- %s пробельные символы
-- %u заглавные буквы
-- %w буквенно-цифровые символы
-- %x шестнадцатеричные цифры

-- Любая из этих букв в верхнем регистре представляет собой дополнение
-- класса, т.е. множество не входящих в него символов. Например, '%А'
-- соответствует всем небуквенным символам

--                         _                            _           _     
--                        (_)                          | |         | |    
--   _ __ ___   __ _  __ _ _  ___   ___ _   _ _ __ ___ | |__   ___ | |___ 
--  | '_ ` _ \ / _` |/ _` | |/ __| / __| | | | '_ ` _ \| '_ \ / _ \| / __|
--  | | | | | | (_| | (_| | | (__  \__ \ |_| | | | | | | |_) | (_) | \__ \
--  |_| |_| |_|\__,_|\__, |_|\___| |___/\__, |_| |_| |_|_.__/ \___/|_|___/
--                    __/ |              __/ |                            
--                   |___/              |___/                             


-- У некоторых символов, называемых магическими символами (magic
-- character), есть особое значение при использовании в образце.

-- Все магические символы
-- (
-- )
-- . любой символ
-- % экранирующий символ, символ начинающий запись класса (%a,%d,...)
-- + модификатор, обозначающий 1 или более повторений
-- - модификатор, обозначающий 0 или более коротких повторений
-- * модификатор, обозначающий 0 или более повторений
-- ? модификатор, обозначающий 0 или 1 вхождение
-- [ для создания множества символов 
-- ] для создания множества символов
-- ^ дополнение любого множества символов, означает любой символ не принадлежащий множеству
-- $

-- Символ '%' работает для этих магических символов как экран. Таким
-- образом, '%.' соответствует точке, а '%%' соответствует самому символу '%'.

-- Множество символов (char-set) позволяет вам создавать ваши
-- собственные классы символов, группируя различные классы и
-- одиночные символы внутри квадратных скобок. Например, множество
-- '[%w_]' соответствует как буквенно-цифровым символам, так и символу
-- подчеркивания; множество '[01]' соответствует двоичным цифрам; а
-- множество '[%[%]]' соответствует квадратным скобкам

-- Пример подсчета гласных в тексте

local text = "despite the cruel world"
local nvow = select(2, string.gsub(text, "[AEIOUaeiou]", ""))
print(nvow)

-- При этом вы также можете включать во множества символов
-- диапазоны, записывая первый и последний символы с дефисом между
-- ними

--                                  _           
--                                 | |          
--    _____  ____ _ _ __ ___  _ __ | | ___  ___ 
--   / _ \ \/ / _` | '_ ` _ \| '_ \| |/ _ \/ __|
--  |  __/>  < (_| | | | | | | |_) | |  __/\__ \
--   \___/_/\_\__,_|_| |_| |_| .__/|_|\___||___/
--                           | |                
--                           |_|                

-- замена всех слов в строке на 'word'
local text = "one, and two; and three"
print(text:gsub("%a+", "word")) --> word, word word; word word

-- нахождение всех чисел в строке
local text = "asbd1723jasbdahd1ajsdn19jd idj923192asjdbahsd1"
for number in text:gmatch("%d+") do
    print(number)
end

-- нахождение всех идентификаторов в строке
print()
local text = "A_1ieubhd123........._db121731nadj.........12312asad3123"
local re = "[%a_][%w_]*"
for identifier in text:gmatch(re) do
    print(identifier)
end
